import Math.Algebra.Ring.Theory.Ideal.TwoSided.Basic
import Math.Algebra.Ring.Theory.Basic

namespace Ideal

variable [RingOps R] [IsRing R]

def setoid (i: Ideal R) : Setoid R where
  r a b := a - b ∈ i
  iseqv := {
    refl x := by
      rw [sub_self]
      apply mem_zero
    symm := by
      intro x y h
      rw [←neg_sub]
      apply mem_neg
      assumption
    trans := by
      intro x y z hx hy
      rw [←add_zero (_ - _), ←sub_self y,
        sub_add_assoc, ←add_sub_assoc, add_comm, sub_eq_add_neg, add_assoc (_ + _),
          add_comm _ y, add_comm _ x, ←sub_eq_add_neg, ←sub_eq_add_neg]
      apply mem_add
      assumption
      assumption
  }

def Quot (i: Ideal R) : Type _ := Quotient (setoid i)

@[cases_eliminator]
private def Quot.ind
  {i: Ideal R} {motive: i.Quot -> Prop} : (mk: ∀x: R, motive (Quotient.mk _ x)) -> ∀q, motive q := Quotient.ind

def toRing (i: Ideal R) : Ring i.Quot := by
  apply Ring.ofMinimalAxioms
  case zero => exact Quotient.mk _ 0
  case one => exact Quotient.mk _ 1
  case neg =>
    apply Quotient.lift (fun a => Quotient.mk _ (-a))
    intro a b eq
    apply Quotient.sound
    show _ - _ ∈ i
    rw [neg_sub_neg, ←neg_sub]
    apply mem_neg
    assumption
  case add =>
    apply Quotient.lift₂ (fun a b => Quotient.mk _ (a + b))
    intro a b c d ac bd
    apply Quotient.sound
    show _ - _ ∈ i
    rw [sub_eq_add_neg, neg_add_rev, add_assoc, ←add_assoc b,
      ←sub_eq_add_neg b, add_comm _ (-c), ←add_assoc,
      ←sub_eq_add_neg]
    apply mem_add
    assumption
    assumption
  case mul =>
    apply Quotient.lift₂ (fun a b => Quotient.mk _ (a * b))
    intro a b c d ac bd
    apply Quotient.sound
    show _ - _ ∈ _
    rw [←add_zero (_ - _), ←add_neg_cancel (a * d), sub_add_assoc,
      ←add_assoc (-_), add_comm _ (a * d), add_comm (_ + _),
      ←add_assoc, ←sub_eq_add_neg, ←sub_eq_add_neg,
      ←mul_sub, ←sub_mul]
    apply mem_add
    apply mem_mul_left
    assumption
    apply mem_mul_right
    assumption

  case add_comm =>
    intro a b
    cases a with | mk a =>
    cases b with | mk b =>
    apply Quotient.sound
    rw [add_comm]
  case add_assoc =>
    intro a b c
    cases a with | mk a =>
    cases b with | mk b =>
    cases c with | mk c =>
    apply Quotient.sound
    rw [add_assoc]
  case mul_assoc =>
    intro a b c
    cases a with | mk a =>
    cases b with | mk b =>
    cases c with | mk c =>
    apply Quotient.sound
    rw [mul_assoc]
  case zero_add =>
    intro a
    cases a with | mk a =>
    apply Quotient.sound
    rw [zero_add]
  case neg_add_cancel =>
    intro a
    cases a with | mk a =>
    apply Quotient.sound
    rw [neg_add_cancel]
  case one_mul =>
    intro a
    cases a with | mk a =>
    apply Quotient.sound
    rw [one_mul]
  case mul_one =>
    intro a
    cases a with | mk a =>
    apply Quotient.sound
    rw [mul_one]
  case mul_add =>
    intro a b c
    cases a with | mk a =>
    cases b with | mk b =>
    cases c with | mk c =>
    apply Quotient.sound
    rw [mul_add]
  case add_mul =>
    intro a b c
    cases a with | mk a =>
    cases b with | mk b =>
    cases c with | mk c =>
    apply Quotient.sound
    rw [add_mul]

-- the canonical projection into the subring generated by the ideal
def mkQuot (i: Ideal R) : R →+* i.toRing where
  toFun := Quotient.mk _
  resp_zero := rfl
  resp_one := rfl
  resp_add := rfl
  resp_mul := rfl

def mkQuot_surj (i: Ideal R) : Function.Surjective i.mkQuot := by
  intro a
  have ⟨x, eq⟩ := Quotient.exists_rep a
  exists x
  rw [←eq]
  rfl

@[simp]
def kernel_mkQuot (i: Ideal R) : Ideal.kernel i.mkQuot = i := by
  ext x
  apply Iff.intro
  intro h
  have : x - 0 ∈ i := Quotient.exact h
  rw [sub_zero] at this
  assumption
  intro h
  apply Quotient.sound
  show _ - _ ∈ i
  rw [sub_zero]; assumption

end Ideal
