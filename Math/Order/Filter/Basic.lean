import Math.Data.Set.Finite
import Math.Data.Set.Lattice
import Math.Function.Basic
import Math.Order.Partial
import Math.Order.Lattice.Complete

structure Filter (Œ±: Type*) [LE Œ±] [Inf Œ±] extends IsLawfulInf Œ± where
  set: Set Œ±
  nonempty: set.Nonempty
  closed_upward: ‚àÄ{x y}, x ‚àà set -> x ‚â§ y -> y ‚àà set
  closed_inf: ‚àÄ{x y}, x ‚àà set -> y ‚àà set -> x ‚äì y ‚àà set

namespace Filter

variable {Œ± : Type*} [LE Œ±] [Inf Œ±]

instance : Membership Œ± (Filter Œ±) :=
  ‚ü®fun F U => U ‚àà F.set‚ü©

instance : LE (Filter Œ±) where
  le a b := ‚àÄx ‚àà b, x ‚àà a

instance : LT (Filter Œ±) where
  lt a b := a ‚â§ b ‚àß ¬¨b ‚â§ a

instance : IsLawfulLT (Filter Œ±) where
  lt_iff_le_and_not_le := Iff.rfl

def top_mem' (top: Œ±) (h: ‚àÄx, x ‚â§ top) (f: Filter Œ±): top ‚àà f := by
  have ‚ü®x, mem‚ü© := f.nonempty
  apply Filter.closed_upward
  assumption
  apply h

@[simp]
def top_mem [Top Œ±] [IsLawfulTop Œ±] (f: Filter Œ±): ‚ä§ ‚àà f := by
  apply top_mem'
  apply le_top

instance [Top Œ±] [IsLawfulTop Œ±] (f: Filter Œ±) : Inhabited f.set where
  default := ‚ü®‚ä§, top_mem f‚ü©

def set_inj : Function.Injective (Filter.set (Œ± := Œ±)) := by
  intro x y h
  cases x; cases y
  congr

def mem_set {f: Filter Œ±} : ‚àÄx, x ‚àà f ‚Üî x ‚àà f.set := by
  intro x
  rfl

@[ext]
def ext {f g: Filter Œ±} : (‚àÄx, x ‚àà f ‚Üî x ‚àà g) -> f = g := by
  intro h
  apply set_inj
  ext
  apply h

protected def copy (f : Filter Œ±) (S : Set Œ±) (hmem : ‚àÄ s, s ‚àà S ‚Üî s ‚àà f) : Filter Œ± := by
  have : S = f.set := Set.ext _ _ hmem
  apply Filter.mk f.toIsLawfulInf S
  rw [this]; exact f.nonempty
  rw [this]; exact f.closed_upward
  rw [this]; exact f.closed_inf

def copy_eq {f: Filter Œ±} {S} (hmem : ‚àÄ s, s ‚àà S ‚Üî s ‚àà f) : f.copy S hmem = f := Filter.ext hmem
@[simp] def mem_copy {f: Filter Œ±} {S hmem} : s ‚àà f.copy S hmem ‚Üî s ‚àà S := Iff.rfl

@[simp]
def closed_inf_iff [IsLawfulInf Œ±] {f: Filter Œ±} {s t : Œ±} : s ‚äì t ‚àà f ‚Üî s ‚àà f ‚àß t ‚àà f := by
  apply Iff.intro
  intro h
  apply And.intro
  apply closed_upward
  assumption
  apply inf_le_left
  apply closed_upward
  assumption
  apply inf_le_right
  intro ‚ü®_, _‚ü©
  apply closed_inf <;> assumption

def closed_finite_sInf [LT Œ±] [InfSet Œ±] [IsCompleteSemiLatticeInf Œ±]
  (s: Set Œ±) [s.IsFinite] (f: Filter Œ±): sInf s ‚àà f ‚Üî s ‚äÜ f.set := by
  induction s using Set.IsFinite.induction with
  | nil =>
    apply Iff.intro
    intro h
    intro _ _; contradiction
    intro
    apply top_mem'
    intro x
    apply le_sInf_empty
  | cons x s hx sfin ih =>
    rw [sInf_insert, closed_inf_iff, ih]
    apply Iff.intro
    intro ‚ü®_, g‚ü©
    intro a h
    cases Set.mem_insert.mp h; subst a
    assumption
    apply g
    assumption
    intro g
    apply And.intro
    apply g
    simp
    apply Set.sub_trans _ g
    intro x
    exact .inr

def exists_mem_le_iff [LT Œ±] [IsPreOrder Œ±] {f: Filter Œ±} : (‚àÉ t ‚àà f, t ‚â§ s) ‚Üî s ‚àà f :=
  ‚ü®fun ‚ü®_, ht, ts‚ü© => closed_upward _ ht ts, fun hs => ‚ü®s, hs, le_refl _‚ü©‚ü©

variable {Œ± : Type u} {Œ≤ : Type v} {Œ≥ : Type w} {Œ¥ : Type*} {Œπ : Sort x}
variable {Œ±: Type*} [LE Œ±] [LT Œ±] [Inf Œ±] [IsSemiLatticeInf Œ±] {f g: Filter Œ±} {s t: Œ±}

section Principal

/-- The principal filter of `s` is the collection of all supersets of `s`. -/
def principal (s : Œ±) : Filter Œ± where
  set := .mk fun x => s ‚â§ x
  nonempty := ‚ü®s, le_refl _‚ü©
  closed_upward := le_trans
  closed_inf := by
    intro x y
    simp [‚ÜêSet.sub_inter]
    intros
    apply And.intro <;> assumption

scoped notation "ùìü" => Filter.principal

@[simp] theorem mem_principal {s t : Œ±} : s ‚àà ùìü t ‚Üî t ‚â§ s := Iff.rfl

theorem mem_principal_self (s : Œ±) : s ‚àà ùìü s := le_refl _

end Principal

namespace Order

def orderEmbSetOp : Filter Œ± ‚Ü™o (Set Œ±)·µí·µñ where
  toFun f := f.set
  inj := Filter.set_inj
  resp_rel := Iff.rfl

instance : IsPartialOrder (Filter Œ±) :=
  orderEmbSetOp.inducedIsPartialOrder'

def le_def : (f ‚â§ g) = ‚àÄx ‚àà g, x ‚àà f := rfl

def not_le : ¬¨f ‚â§ g ‚Üî ‚àÉs ‚àà g, s ‚àâ f := by
  simp [le_def, Classical.not_forall]

end Order

section Generate

inductive GenerateSets (g : Set Œ±) : Œ± ‚Üí Prop
  | basic {s : Œ±} : s ‚àà g ‚Üí GenerateSets g s
  | up {s t : Œ±} : GenerateSets g s ‚Üí s ‚â§ t ‚Üí GenerateSets g t
  | inf {s t : Œ±} : GenerateSets g s ‚Üí GenerateSets g t ‚Üí GenerateSets g (s ‚äì t)

def generate_of_nonempty (g: Set Œ±) (ne: g.Nonempty) : Filter Œ± where
  set := Set.mk (GenerateSets g)
  nonempty := by
    obtain ‚ü®x, ne‚ü© := ne
    exists x
    apply GenerateSets.basic
    assumption
  closed_upward := by
    intro x y hx hxy
    apply GenerateSets.up
    assumption
    assumption
  closed_inf := by
    intro x y hx hy
    apply GenerateSets.inf
    assumption
    assumption

def generate [Top Œ±] [IsLawfulTop Œ±] (g: Set Œ±) : Filter Œ± := generate_of_nonempty (insert ‚ä§ g) Set.nonempty_insert

def mem_generate_of_mem {s : Set Œ±} {x : Œ±} (h : x ‚àà s) {h': s.Nonempty} :
  x ‚àà generate_of_nonempty s h' := GenerateSets.basic h

def le_generate_iff {s : Set Œ±} {f : Filter Œ±} {ne: s.Nonempty} : f ‚â§ generate_of_nonempty s ne ‚Üî s ‚äÜ f.set := by
  apply Iff.intro
  intro h x mem
  apply h
  apply GenerateSets.basic
  assumption
  intro h x mem
  induction mem with
  | basic =>
    apply h
    assumption
  | up =>
    apply f.closed_upward
    assumption
    assumption
  | inf =>
    apply f.closed_inf
    assumption
    assumption

def mem_generate_iff [InfSet Œ±] [IsCompleteSemiLatticeInf Œ±] {s : Set Œ±} {ne: s.Nonempty} {x: Œ±} : x ‚àà generate_of_nonempty s ne ‚Üî ‚àÉ t ‚äÜ s, Set.IsFinite t ‚àß sInf t ‚â§ x := by
  apply Iff.intro
  intro mem
  induction mem with
  | basic =>
    rename_i s' _
    exists {s'}
    refine ‚ü®?_, ?_, ?_‚ü©
    rwa [Set.singleton_sub]
    infer_instance
    rw [sInf_singleton]
  | up _ h ih =>
    obtain ‚ü®t, sub, tfin, le‚ü© := ih
    refine ‚ü®t, ?_, tfin, le_trans le ?_‚ü©
    assumption
    assumption
  | inf _ _ ih‚ÇÄ ih‚ÇÅ =>
    obtain ‚ü®s, ssub, sfin, sle‚ü© := ih‚ÇÄ
    obtain ‚ü®t, tsub, tfin, tle‚ü© := ih‚ÇÅ
    refine ‚ü®s ‚à™ t, ?_, ?_, ?_‚ü©
    rw [‚ÜêSet.union_sub]
    apply And.intro <;> assumption
    infer_instance
    rw [sInf_union]
    apply inf_le_inf
    assumption
    assumption
  intro ‚ü®t, sub, fin, le‚ü©
  apply closed_upward _ _ le
  show sInf t ‚àà generate_of_nonempty s ne
  apply (closed_finite_sInf _ _).mpr
  intro x mem
  apply GenerateSets.basic
  apply sub
  assumption

@[simp]
def generate_singleton (a: Set Œ±) : generate_of_nonempty {a} (Set.nonempty_singleton _) = ùìü a := by
  apply le_antisymm
  intro x mem
  rw [mem_principal] at mem
  rw [mem_generate_iff]
  refine ‚ü®{a}, Set.sub_refl _, ?_, ?_‚ü©
  infer_instance
  rw [sInf_singleton]
  assumption
  intro x mem
  rw [mem_generate_iff] at mem
  obtain ‚ü®t, t_sub, t_fin, le‚ü© := mem
  rw [mem_principal]
  apply le_trans _ le
  apply le_sInf
  intro x mem
  cases t_sub _ mem
  rfl

end Generate

def join [Top Œ±] [IsLawfulTop Œ±] (fs : Filter (Set (Filter Œ±))) : Filter Œ± where
  set := Set.mk fun s => (Set.mk fun t : Filter Œ± => s ‚àà t) ‚àà fs
  nonempty := by
    obtain ‚ü®x, x_in_fs‚ü© := fs.nonempty
    replace x_in_fs: x ‚àà fs := x_in_fs
    refine ‚ü®‚ä§, ?_‚ü©
    rw [Set.mk_mem]
    have : (Set.mk fun t: Filter Œ± => ‚ä§ ‚àà t) = ‚ä§ := by
      apply Set.ext_univ
      intro f
      apply top_mem
    rw [this]
    apply top_mem
  closed_upward := by
    simp [Set.mk_mem]
    intro x y mem_fs sub
    apply closed_upward
    assumption
    intro f
    simp
    intro hx
    apply closed_upward
    assumption
    assumption
  closed_inf := by
    simp [Set.mk_mem]
    intro x y hx hy
    suffices ({ Mem := fun t => x ‚àà t ‚àß y ‚àà t }: Set (Filter _)) = { Mem := fun t => x ‚àà t } ‚à© { Mem := fun t => y ‚àà t } by
      rw [this]
      apply closed_inf
      assumption
      assumption
    ext k
    simp [Set.mem_inter]

@[simp]
def mem_join [Top Œ±] [IsLawfulTop Œ±] {s : Œ±} {f : Filter (Set (Filter Œ±))} : s ‚àà join f ‚Üî (Set.mk fun t => s ‚àà t) ‚àà f :=
  Iff.rfl

instance [Top Œ±] [IsLawfulTop Œ±] : Top (Filter Œ±) where
  top := {
    set := {‚ä§}
    nonempty := ‚ü®‚ä§, Set.mem_singleton.mp rfl‚ü©
    closed_upward := by
      intro x y eq h
      subst x
      apply le_antisymm
      apply le_top
      assumption
    closed_inf := by
      intro x y _ _; subst x; subst y
      simp
  }

instance [h: Nonempty Œ±] : Bot (Filter Œ±) where
  bot := {
    set := ‚ä§
    nonempty :=
      have ‚ü®x‚ü© := h
      ‚ü®x, Set.mem_univ _‚ü©
    closed_upward := by
      intros
      apply Set.mem_univ
    closed_inf := by
      intros
      apply Set.mem_univ
  }

instance [Top Œ±] [IsLawfulTop Œ±] [InfSet Œ±] : InfSet (Filter Œ±) where
  sInf fs := generate (Set.mk fun s => ‚àÉf: fs -> Œ±, (‚àÄx, (f x) ‚àà x.val) ‚àß s = iInf f)

instance [Top Œ±] [IsLawfulTop Œ±] : SupSet (Filter Œ±) where
  sSup := join ‚àò ùìü

instance [Top Œ±] [IsLawfulTop Œ±] : Inf (Filter Œ±) where
  inf a b := generate (Set.mk fun s => ‚àÉf‚ÇÄ f‚ÇÅ: Œ±, f‚ÇÄ ‚àà a ‚àß f‚ÇÅ ‚àà b ‚àß s = f‚ÇÄ ‚äì f‚ÇÅ)
instance [Top Œ±] [IsLawfulTop Œ±] : Sup (Filter Œ±) where
  sup a b := sSup {a, b}

instance [Top Œ±] [IsLawfulTop Œ±] [InfSet Œ±] [IsCompleteSemiLatticeInf Œ±] : IsCompleteLattice (Filter Œ±) where
  le_top := by
    intro x a mem; subst a
    apply top_mem
  bot_le := by
    intro x a mem
    trivial
  le_sup_left := by
    intro f g a mem
    apply mem
    simp
  le_sup_right := by
    intro f g a mem
    apply mem
    simp
  inf_le_left := by
    intro f g x mem
    apply Filter.GenerateSets.basic
    rw [Set.mem_insert]; right
    refine ‚ü®x, ‚ä§, ?_, ?_, ?_‚ü©
    assumption
    repeat simp
  inf_le_right := by
    intro f g x mem
    apply Filter.GenerateSets.basic
    rw [Set.mem_insert]; right
    refine ‚ü®‚ä§, x, ?_, ?_, ?_‚ü©
    simp
    assumption
    simp
  sup_le := by
    intro f g k kf kg x mem
    have := kf x mem
    have := kg x mem
    intro i mem
    simp at mem; cases mem <;> subst i
    assumption
    assumption
  le_inf := by
    intro a b k ka kb x mem
    induction mem with
    | up =>
      apply closed_upward
      assumption
      assumption
    | inf =>
      apply closed_inf
      assumption
      assumption
    | basic h =>
      cases Set.mem_insert.mp h <;> rename_i h
      subst h; apply top_mem
      obtain ‚ü®f‚ÇÄ, f‚ÇÅ, f‚ÇÄ_in_a, f‚ÇÅ_in_b, eq‚ü© := h
      subst eq; clear h
      apply closed_inf
      apply ka; assumption
      apply kb; assumption
  le_sSup := by
    intro fs f hf x hx
    apply hx
    assumption
  sSup_le := by
    intro f fs ih x mem g hg
    apply ih
    assumption
    assumption
  sInf_le := by
    intro fs f hf x hx
    apply GenerateSets.basic
    simp; right
    refine ‚ü®?_, ?_, ?_‚ü©
    sorry
    sorry
    sorry
  le_sInf := sorry


end Filter
